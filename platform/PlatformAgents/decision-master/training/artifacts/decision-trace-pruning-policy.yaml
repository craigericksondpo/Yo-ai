# Pruning policy for decision traces
# You want something that can live as a Policy document tied to a pruning daemon. This is intentionally generic: you can plug in regulator windows, severity-based retention, and snapshot strategies.
version: "1.0"
kind: PruningPolicy
metadata:
  name: "decision-trace-pruning"
  applies_to:
    event_type: "decision.trace"
    topics:
      - "decision.traces"
strategy:
  base_retention:
    # Minimum retention for all decision traces
    min_retention_days: 365
    # Hard cap; older events must be pruned unless overridden by holds
    max_retention_days: 1825

  by_decision_type:
    - decision: "approval"
      min_retention_days: 365
    - decision: "denial"
      min_retention_days: 730         # keep denials longer
    - decision: "partial-approval"
      min_retention_days: 730

  risk_based_overrides:
    enabled: true
    # If risk_score is present in any step, use this logic
    thresholds:
      - name: "high-risk"
        condition: "max_step_output('risk-evaluation', 'risk_score') >= 0.7"
        min_retention_days: 1825
      - name: "medium-risk"
        condition: "max_step_output('risk-evaluation', 'risk_score') >= 0.4"
        min_retention_days: 1095

  legal_holds:
    honored_fields:
      - "audit.legal_hold"       # boolean flag set externally
      - "audit.case_id"          # if present, do not prune
    behavior:
      if_legal_hold: "suspend-pruning"

  snapshots:
    # Optionally keep compact snapshots after pruning full traces
    enabled: true
    snapshot_topic: "decision.trace-snapshots"
    snapshot_fields:
      - "event_id"
      - "timestamp"
      - "decision_master"
      - "request.request_id"
      - "request.target_registered_agent_id"
      - "final_decision"
      - "audit.hash_chain_current"

  enforcement:
    # How often the pruning daemon should run
    schedule_cron: "0 3 * * *"
    dry_run_mode: false
